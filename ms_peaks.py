####################################################################################################
#
#   ms_peaks.py
#
#   A library to use and Analyse Mass Spectrum Data
#
#   Utilizes raw text or mzXML files generated by [at least Mahdi] Mass Spectrometers
#
#   C. Bryan Daniels, cdaniels@nandor.net
#
#   1/22/2024
#
####################################################################################################


####################################################################################################
#
# Description of primary data type: Peaks
#
# Peaks are a tuple of two numpy arrays, of which the first array contains values of mz and the
# second the values of intensity. The data type is not strictly enforced as a class,
# but could easily be implemented as such. (Types are loosely defined in Haskell Style)
#
# Type Peaks = ([mz], [intensity])
#
# Type mz = [Float]
#
# Type Intensity = [Int]
#
####################################################################################################


####################################################################################################
#
#   - Primitives for data type: Peaks
#
#   - General Functions
#
####################################################################################################


import pyopenms as oms
from scipy.signal import find_peaks
import pandas as pd
import numpy as np


def Peaks(mz, intensity):
    """
    Peaks :: [mz] -> [Intensity] -> Peaks
    Create a Peaks from lists of mz and intensity
    """
    if not (isinstance(mz, (list, np.ndarray)) and isinstance(intensity, (list, np.ndarray))):
        return "error: both mz and intensity must be either a list or a numpy.array type"
    if isinstance(mz, list): mz = np.array(mz)
    if isinstance(intensity, list): intensity = np.array(intensity)
    mz = np.round(mz, 3)
    intensity = intensity.astype(np.int64)
    return (mz,intensity)

def read_ms_mzXML(file):
    """
    read_ms_mzXML :: mzXML_file -> Peaks
    Read mzXML file format and return Peaks
    """
    exp = oms.MSExperiment()
    oms.MzXMLFile().load(file, exp)
    mz, intensity = exp.getSpectrum(0).get_peaks()
    return Peaks(mz, intensity)

def read_ms_txt(file):
    """
    read_ms_txt :: file -> Peaks
    Read raw ms file text format and returns Peaks
    """
    df = pd.read_csv(file, sep=" ", header=None)
    mz = df.iloc[:,0].to_numpy()
    intensity = df.iloc[:,1].to_numpy()
    return Peaks(mz, intensity)

def is_peaks(peaks):
    """
    is_peaks :: Peaks -> Bool
    If peaks is of type Peaks returns True; otherwise returns False
    """
    if isinstance(peaks, tuple) and len(peaks) == 2:
        return all(isinstance(item, np.ndarray) for item in peaks)
    return False

def check_peaks(peaks):
    """
    check_peaks -> Peaks -> IO
    Only returns False if peaks is not of type Peaks; otherwise does nothing
    """
    if not is_peaks(peaks): return(f"error: {peaks} is not of type peaks")

def get_mz(peaks):
    """
    get_mz :: Peaks -> mz
    Returns mz array of peaks
    """
    check_peaks(peaks)
    return peaks[0]

def get_intensity(peaks):
    """
    get_intensity :: Peaks -> Intensity
    Returns intensity of peaks
    """
    check_peaks(peaks)
    return is_peaks and peaks[1]

def empty_peaks(peaks):
    """
    empty_peaks :: Peaks -> Bool
    Returns True if peaks is empty and False if not
    """
    if not is_peaks(peaks):
        print(f"error: {peaks} is not of type peaks")
        return False
    return len(get_mz(peaks)) == 0

def len_peaks(peaks):
    """
    len_peaks :: Peaks -> Int
    Returns length of peaks
    """
    check_peaks(peaks)
    return len(get_mz(peaks))

def peak(peaks, nth=0):
    """
    peak:: [peaks] -> peaks
    Return nth peak; default is first peak
    """
    check_peaks(peaks)
    if empty_peaks(peaks): return(f"error: {peaks} is empty")
    return (np.array([peaks[0][nth]]), np.array([peaks[1][nth]]))

def mz(peaks, nth=0):
    """
    mz :: peaks -> mz
    Return nth mz; default is first mz
    """
    check_peaks(peaks)
    if empty_peaks(peaks): return(f"error: {peaks} is empty")
    return peak(peaks, nth)[0][0]

def intensity(peaks, nth=0):
    """
    intensity :: peaks -> Intensity
    Return nth intensity; default is first intensity
    """
    check_peaks(peaks)
    if empty_peaks(peaks): return(f"error: {peaks} is empty")
    return peak(peaks, nth)[1][0]

def range_peaks(peaks, mz_base, delta=2):
    """
    range_peaks :: Peaks -> Real -> Int -> Peaks
    Return peaks within the range:  (mz_base - delta) < mz < (mz_base + delta)
    """
    idx = np.where(np.abs(get_mz(peaks) - mz_base) < delta)
    return Peaks(get_mz(peaks)[idx], get_intensity(peaks)[idx])


def area_peak(peaks, mz_base, dist = 0.5):
    """
    area_peak :: Peaks -> mz -> Real -> Int
    Return sum of intensity within range_peaks(peaks, mz_base, dist)
    """
    return np.sum(get_intensity(range_peaks(peaks, mz_base, dist)))

def call_peaks(peaks, height = 1500):
    """
    call_peaks :: Peaks -> Int -> Peaks
    Calls peaks with intensity > height
    """
    mz, intensity = peaks
    idx = find_peaks(intensity, height)[0] # scipy fn
    return Peaks(mz[idx], intensity[idx])

def group_peaks(peaks, height = 1500, dist=5):
    """
    group_peaks :: Peaks -> Int -> [Peaks]
    Returns a group of peaks, each grouped of which is within a distance dist of each other
    """
    mz, intensity = call_peaks(peaks, height)
    # Sort the array along with their original idx
    sorted_mz_with_idx = sorted(enumerate(mz), key=lambda x: x[1])
    # Initialize the first group
    groups = [[sorted_mz_with_idx[0][0]]]
    # Iterate and group elements
    for idx, element in sorted_mz_with_idx[1:]:
        # Check if the element is close enough to the last element of the last group
        if element - mz[groups[-1][-1]] <= dist:
            groups[-1].append(idx)
        else:
            # Start a new group
            groups.append([idx])
    return [Peaks(mz[idx], intensity[idx]) for idx in groups]

def apex_peaks(peaks, height = 1500, dist = 5):
    """
    apexes :: Peaks -> Peaks
    Returns the peak with the highest intensity for each group returned by group_peaks
    Note: Number of apex peaks can very with selection of height and dist. The defaults work well.
          To optimize, consider modifying to apex_peaks to loop through combinations of paramaters.
    """
    groups = group_peaks(peaks, height,  dist)
    mz = [mz[np.argmax(intensity)] for mz, intensity in groups]
    intensity = [intensity[np.argmax(intensity)] for mz, intensity in groups]
    return Peaks(mz, intensity)


